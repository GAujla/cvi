# -*- coding: utf-8 -*-
"""cvi formulas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15jl32wbrXNY8I2HaK4hSK3ZrpCw4Zk65
"""

#thin lens equation

#given the distance of the object from the lens (u) and the distance of the image from the lens (v)
def find_f(u,v):
  (1/f) = (1/u) + (1/v)
  print(f)
  return f

#given the distance of the object from the lens (u) and the focal length (f)
def find_v(f,u):
  (1/v) = (1/f) - (1/u)
  print(v)
  return v

#given the distance of the distance of the image from the lens (v) and the focal length (f)
def find_u(f,v):
  (1/u) = (1/f) - (1/v)
  print(u)
  return u

# 2D and 3D Projection 
def xprime(fprime,z,x):
  xprime = (fprime / z) * x
  print(xprime)
  return xprime

def yprime3D(fprime,z,y):
  yprime = (fprime / z) * y
  print(yprime)
  return yprime

def fprime(xprime,z,x):
  fprime = (z * xprime) / x
  print(fprime)
  return fprime

def x(fprime,z,xprime):
  x = (xprime * z) / fprime
  print(x)
  return x

def z(frime, xprime, x):
  z = (x / xprime) * fprime
  print (z)
  return z

def fprime3D(zprime):
  fprime = zprime
  print(fprime)
  return fprime

#Relating real world coordinates to camera coordinates WHEN PIXEL SIZE IS GIVEN, do it manually

#Relating real world coordinates to camera coordinates WHEN PIXEL SIZE IS NOT GIVEN
import numpy as np
#given the coordinates of a point in world reference frame (x,y,z), we can convert it to image reference frame (u,v)
#where (x,y,z) are coordinates in the real world
#a,b (alpha and beta) are magnification factors in x and y direction
#ox, oy are the coordinated of the center point of the camera
def pix_to_cam(x,y,z,a,b,ox,oy):
  (u,v,_) = (1/z) * np.matmul(np.matmul(np.array([[a,0,ox], [0,b,oy], [0,0,1]]), np.array([[1,0,0,0],[0,1,0,0],[0,0,1,0]])), np.array([x,y,z,1]))
  print([u,v])
  return [u,v]

